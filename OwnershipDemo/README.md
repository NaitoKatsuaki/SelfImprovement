# 学習した内容
## 所有権の移動(move)と右辺値参照
### 所有権とは？
所有権 = 「リソースの破棄に責任をだれが持つか？」
変数1から変数2に所有権をmoveすると、変数1のアドレスｈが変数2に移動され、変数1はnullptrになる。よって、変数1の破棄のタイミングやdelete 変数1をしても、解放は行われない。変数2に所有権が移っているので、変数2の破棄のタイミングやdelete 変数2で、解放される。注意点としては、メモリ上で見ると、変数1の確保タイミングから、メモリ上は全く移動やコピーが走らない。あくまで、そのアドレスをだれが保持するか？破棄の開放は誰が行うか？だけが移動する

### 右辺値参照とは？
一次的なオブジェクト $x = 10$における10とかと同じ。として参照される。通常ムーブコンストラクタの中でmoveでcastして、さらにアドレスのコピーなどをして使う。
``` C++
FrameBuffer fb1;
foo(std::move(fb1));
```
は以下と同じで、実はCASTしかしていない。
``` C++ 
foo(static_cast<FrameBuffer&&>(fb1));
```
「このオブジェクトをもう使わないので、“右辺値扱い”で渡してよい」とコンパイラに伝えるだけ。fb1はメモリ上に残ったまま。オブジェクトの寿命も変わらない。
オブジェクトを実際に移動・破壊するわけではない。
fb1 はメモリ上に残り、寿命も変わらない。
ただし、関数側では「中身を奪って良い」として扱われる。

下記の説明が最もわかりやすい。
https://zenn.dev/dec9ue/books/8c59757478a547/viewer/83003e

## unique_ptr


# 課題の解答
- [x] : RAIIと所有権の概念を説明できる
  - RAIIとは、インスタンス化の際にコンストラクタが呼ばれるが、このタイミングでリソースの確保(new)を行い、オブジェクトが破棄されるタイミングでデストラクタが呼ばれ、このタイミングでリソースが解放されるようにすること。そしてデータの実態はstd::unique_ptrなどを利用して、これをラップしたクラスを作ることで、リソースの開放漏れや二重開放などが起こらないようにする設計を行う。
  - 所有権とは、リソースの開放の責務をだれが行うかのこと。右辺値参照引数のmoveコンストラクタを実装しておくことで、左辺値として定義した変数の開放の責務を新たに宣言した変数にmoveすることができるようになる。単に変数を別に変数に渡すだけで、元の変数が不要な場合は、```new変数 = std::move(old変数)```とすることで、通常のコピーコンストラクタやコピー代入演算子による変数の代入とは違って、メモリ上の値をまるまる別のメモリ上にコピーする処理が走らないので、高速に処理することができるといううまみがある。このとき所有権は```new変数```に移っているので、old変数の開放を機にする必要がなく細心の変数に対して解放を行うという直感的に正しい実装になる。またRAIIと組み合わせておけば、そもそも解放を直接意識しなくてもよくなるため、コードの安全性が高まる。
- [x] : unique_ptr/shared_ptr/weak_ptrの違いの説明
  - [x] : unique_ptr
    - リソースの所有権は必ず1つで、std::moveを使って所有権のみ渡すようにする。参照カウントでいうと必ず0,1で、1⇒0のタイミングで自動破棄される。
  - [x] : shared_ptr
    - リソースの所有権がN(0以上の整数)であり得る。代入演算子風に描くことで所有権がコピーされる。参照カウントが0個になったタイミングで自動破棄される。
  - [x] : weak_ptr
    - リソースへの参照は持つが、参照カウントを持たない。つまり、解放の責務はほかに任せて、値を参照で使いたいとき。所有権を持つこと無く共有リソースの監視／利用をしたいかどうか 
- [x] : ムーブ専用クラスを自作できる
  - FrameBufferクラスのmoveコンストラクタとムーブ代入演算子の実装で対応済み。ポイントは引数を右辺値参照にすること/コンストラクタ内部でデータの実態を表すunique_ptrのmoveを行って、引数を右辺値参照に型変換してデータの右辺値参照を渡すこと。これによってコンパイラが、右辺値参照で渡す際に、old変数がダングリングポインタにならないようにnullptrにして、新しい変数にアドレスをコピーされる。
- [x] : 例外安全なリソース管理クラスを設計できる
  - 要はFrameBufferクラスのように、unique_ptrをラップようなクラスを都度作ることで、例外が起きてもちゃんと解放が行われるようになるし、これを使うクライアントコードは解放漏れを機にする必要が泣かくなる。
     